\documentclass{article}

\usepackage{xcolor}

\newcommand\todo[1]{\textcolor{red}{#1}}

\def\frontmatter{%
    \pagenumbering{roman}
    \setcounter{page}{1}
    \renewcommand{\thesection}{\Roman{section}}
}%

\def\mainmatter{%
    \pagenumbering{arabic}
    \setcounter{page}{1}
    \setcounter{section}{0}
    \renewcommand{\thesection}{\arabic{section}}
}%

\author{
  Billingham, John\\
  King, Brandy\\
  LaCognata, Nicolas\\
  Simonian, Sean\\\\
  {\small Advisor: Carbone, Tom}
}

\title{Project Solenodon}

\begin{document}

\frontmatter

\maketitle

\newpage
\tableofcontents

\newpage
\mainmatter
\section{Executive Summary}

\subsection{Goals and Objectives}

\subsubsection{Statement of Intent}
The purpose of this project is to provide a bridge for potential computer
scientists to learn and explore the fundamentals of solving problems
computationally. Providing this insight is non-trivial, especially in
traditional teaching environments. Our approach is to present common
introductory computer science concepts in the form of puzzles and visuals in a
2D video game. This game will provide a means for those interested in
computational thinking to learn in a fun and engaging environment. The players
won’t be expected to set up a development environment, or learn the nuances of
specific programming languages. All of the concepts necessary to solving the
challenges should be taught to (or discovered by) the player through interactive
gameplay. Framing this tool as a game is an important distinction, as it allows
us to deliberately craft the players’ experience and deliver specific learning
outcomes.\\

Currently, there are many game offerings that focus on teaching computational
thinking, with most of them focusing on using “code” solutions for puzzle
solving. However, we have found that they tend to fall far on either end of a
spectrum; either the game is too abstract and the computational thinking aspect
is not well emphasized, or the game is too technical and therefore inaccessible
to beginner level programmers. It is our intention to provide a game that falls
between these two extremes on the spectrum. We want our game to teach the user
about the different commands and how they can be used to solve the puzzles
provided. This will lean away from some of the more abstract puzzle-solvers,
where the movements manipulate a character spatially instead of using the
sequence of commands to solve the puzzle. Conversely, we will use clear and
simple language coupled with visual and audio cues to explain commands and data
structures in the game, while abstracting the intricacies of language specific
commands or complex details about these elements. This will help new programmers
to more easily understand the concepts of computer science and use them to solve
the puzzles without requiring them to be familiar with language specific syntax
or the complexities of managing data structures in code. For example, we can
provide a heap data structure for them to use and explain its general purpose
for sorting and storing data without forcing the user to construct or maintain
the heap. Taking away the technical aspects of utilizing these elements will
allow players to focus on learning and understanding the tools they are given
and how to apply those tools to solve the problem presented.

\newpage
\section{Project Significance}

\subsection{Personal Motivations}
\subsubsection{Brandy King}
With career goals of being an Instructor of Computer Science, I was immediately
intrigued during this project proposal. As a Teaching Assistant, I have spent a
lot of time working with students in introductory level Computer Science
courses. It is often a difficult subject for students who come in with little to
no experience, and I have watched many students struggle with learning a new
programming language at the same time that they are learning to use that
language to effectively solve problems that they have been presented. I loved
the idea of an interactive game that would not only help teach people some of
the basics, but also reinforce efficient problem solving with computational
logic. I hope that the finished project we aim to provide will help students
entering computer science classes by giving them confidence in their knowledge
of concepts.\\

I am also very excited to learn new technologies, work with a team, and
experiment with game development. As it currently stands, most of my experience
with software development has been strictly course driven. Balancing full time
studies, a full-time work schedule, and a family and personal life leaves me
with extremely limited free time to pursue personal projects or devote time to
learning things outside of lectures. Working on this project will give me the
opportunity to expand my knowledge in a new programming language and to work
with a game engine. I have always been enthusiastic about video games, and I see
their value as an engaging form of media. Being able to use this platform to
convey instruction in Computer Science is a marriage of two things I am very
passionate about.

\subsubsection{John Billingham}
Coming from having no programming experience prior to college, I have seen and
experienced the disconnect between learning the correct syntax of a programming
language, and being able to think and solve problems programmatically. This game
has an aim to teach basic logic and computational thinking skills to it’s users
and I believe that this can close that specified gap that many of us have felt.

\subsubsection{Nicolas LaCognata}
I pitched this project, and I care a great deal about it. I centered my
undergraduate studies around games and simulations, and I’m excited to apply my
knowledge to create a game that is both highly engaging and educational. There
have been many occasions where my desire to pursue a career in game development
has been viewed negatively, and I’d like to be able to point to this project as
proof that the skills I have learned can provide a valuable experience to
others.\\

The idea for this project mainly came from my experience as a tutor for Intro to
C. When I took the class, I had prior programming experience. In effect, I
checked out and coasted through it without really seeing what was going on.
Going back and seeing the challenges new programmers really face was a profound
experience. I want this game to help aspiring programmers, and spark interest in
our field for those on the outskirts.

\subsubsection{Sean Simonian}
Like many computer science students, I had very little programming experience
and next to zero understanding of most computer science concepts when I first
started at UCF, and I quickly found myself struggling immensely with the
introductory computer science courses. The main reason I was able to get through
the first year of computer science courses was because of friends who were
willing to help tutor me in the areas where the lectures were not effective
enough at explaining concepts to beginners. In later years, I became a much
better computer science student, and found myself in the opposite role as
before. I have had the opportunity to serve as a mentor to other students
struggling with computer science, and often tutored several people whose
professors’ teaching styles failed to meet the needs of the students. By
experiencing both sides of these situations, I have learned quite a bit about
what beginners struggle with when learning computer science concepts, and how
these concepts need to be broken down and taught in relatable ways. I am excited
about the opportunity to create a tool that can help individuals build a strong
foundation for understanding computer science.\\

Video game development was the primary reason I decided to study computer
science, which motivated me to learn to create a video game for my high school
senior project, and joined the Game Dev Knights club at UCF during my freshman
year. Later I moved away from the goal of game development in favor of interests
in software development and cyber security, so this project will provide the
opportunity to more thoroughly explore game development in a real setting with a
team without having to change the direction of my studies or career path.\\

My technical experience includes working as a software engineer for Harris
Corporation supporting programs for the Federal Aviation Administration, and
later working as a software developer for Texas Instruments supporting their
internal Data Lifecycle Management project. I have also completed a minor in
Secure Computing and Networks, have been an active member of UCF’s Collegiate
Cyber Defense Club for the past few years, and am currently part of the
operations team for Hack@UCF to support the club. Each of these experiences has
helped me build various skills that should be useful for this project. Working
on this game will provide the opportunity to develop additional skills in areas
where I would otherwise be lacking.

\subsection{Broader Impacts}

The audience that this game is geared towards are people with little prior
technical experience relating to computer science who are just beginning to
learn how to program and learn computational logic. The aim of this project is
to create an engaging platform for players to explore the process of approaching
and solving problems computationally, build a foundation for understanding the
principles of computer science, and prepare users for challenges they may face
in their future studies of computer science.\\

At UCF, the difficulties that surround new computer science students are easily
seen in the courses leading up to the foundation exam, perhaps the most obvious
with Intro to C. Students in that class are immediately faced with two major
tasks: learn to solve problems programmatically, and learn the structure and
syntax of C. Students often enter the class without any experience with either
of these tasks, and many students end up feeling lost and discouraged early
on.\\

Another aspect that should be considered is the unfortunate number of
underrepresented groups in STEM fields, especially computer science. There are
many factors that can contribute to this issue, such as individual backgrounds,
ethnicity, gender, social stigmas, disabilities, or the common lack of
preparation from underfunded public schools. Students who are already facing
pressures related to these issues may be more inclined to give up on computer
science when they feel lost in their first year.\\

As with any group of technically proficient individuals, it is not uncommon to
find that a number of the more experienced members inadvertently reinforce a
“gatekeeping” mindset towards STEM majors by supporting weed out classes and
survival of the fittest. This behavior can occur with upper level computer
science students or graduates who have seen the large number of highly
intelligent students who fail or give up on computer science, which could often
be avoided if better education and resources were widely available.\\

For situations like any of those described above, a resource that can provide
the tools necessary to understand and approach the concepts and challenges of
computer science in an effective manner would be an invaluable resource to many
individuals. Our project will provide these tools in an engaging format,
enabling players of different backgrounds and experience levels to cultivate an
intuitive understanding of computational thinking, while giving them a platform
to apply their newfound perspective to approach and solve various problems. As a
result, we hope that our game and similar resources help more students of all
backgrounds to successfully pursue their passion for computer science.\\

While the game strives to close the bridge between logic and syntax, by focusing
on the former it can benefit a broader scope of people, regardless of if they
plan to become software developers, or simply wish to learn the logic of
computer systems. The puzzles can act as a means to spark users’ interest in
computer science, or just to be enjoyed by a spectrum of developers and
engineers (students, industry, etc), as the levels scale in complexity. By
introducing a variety of puzzles that are solved using similar methods and
mechanics should help players to start recognizing similar patterns between
different problems.\\

The game will have an engaging and easy to use interface to provide educational
value with puzzle-based challenges. The mechanics of the game will be easy to
pick up, since learning to play the game should not feel like a difficult task
of its own. The scaling of puzzle difficulty will allow the game to be welcoming
to beginners by incrementally introducing higher complexity tools and abilities
as the levels progress. By providing feedback on the basic runtime and space
complexities of working solutions, players will have the ability to learn how to
solve problems efficiently.\\

\newpage
\section{Legal, Ethical, and Privacy Issues}
Since this project will hopefully have real-world impacts, there are a number of
potential issues and precautions to address from the beginning. The fact that
this project is not sponsored, and is not expected to generate any revenue
directly or indirectly, suggests fewer potential legal issues than sponsored
projects or projects that would provide a company with monetary gain. We have to
be careful of potential copyright infringement, since creating a game that is
very similar to existing games could introduce legal issues. If we use any
publicly available game assets, then we will have to ensure that we are
compliant with any terms of use. We plan on using original artwork for the game,
and the art will have to be royalty free, along with all other game assets.
Another legal consideration is the fact that members of our group have had to
sign non-disclosure agreements with multiple large companies relating to past
employment, but this is not expected to cause any issues at this time.\\

Ethical considerations must be made for our game and the testing we perform for
development. In order to optimize the educational capabilities of the game, we
are conducting tests on as many unaffiliated individuals as we can throughout
the development process. When performing any psychological tests, it is
important to create a controlled environment. Participants should be given a
waiver to sign before they participate in a study. For the sake of simplifying
the process and minimizing liability, we will not be performing these tests on
minors, nor will we include minors in our target audience. Since the target
audience for our game is people with little to no experience learning computer
science and computational thinking (primarily around the college freshman
level), we are able to set the target age at over 18, while also expecting that
the game would be useful for a number of younger students in the middle and high
school range.\\

Our team strongly supports the universal right to privacy for all people, and
our product will reflect that. No personally identifiable information will be
intentionally collected or stored about users. If our project includes a web
component and/or remote database, all data should be encrypted while in transit
or at rest. If we need to create user accounts and/or collect user’s email
addresses for scalability to verify user accounts, then those will have to be
encrypted and stored securely.

\newpage
\section{Requirements}
\subsection{Functional Requirements}
\begin{enumerate}
  \item Product will help users learn/understand foundational computer science
  concepts.
  \item Product will be a playable video game.
  \item Game will have an easy to use 2D interface to encourage beginners.
  \item Present the user with various challenges and puzzles to solve.
  \item Provide beginner level explanations to concepts as they’re introduced
  \item Present visuals to help user understand concepts that are being
  introduced or applied.
  \item Enable user to apply concepts to solve subsequent challenges once it’s
  been introduced.
  \item Use a simple pseudo-language that enables user to create solutions with
  computational logic but without writing code.
  \item Provide hints to user when needed.
  \item Allow user to see their previous solution attempts for a level.
  \item Notify user if they retry a previous solution that failed.
  \item Help guide users towards an appropriate solution.
  \item Break down complex challenges into smaller parts with guidance/
  checkpoints for each main step.
  \item Simulate the execution of player’s solutions with animated visuals
  corresponding to the steps.
  \item Inform player of the accuracy of their solution.
  \item Inform player of the efficiency of their solution.
  \item Allow user to speed up the simulations if they are doing well with the
  current challenges.
  \item Make minor interface adaptations if user is struggling with a challenge:
  \begin{itemize}
    \item Disable ability to speed up simulation.
    \item Provide hints for common mistakes or for how to approach the problem.
    \item Highlight components of solution that cause errors.
  \end{itemize}
  \item Halt solution simulation in the case of:
  \begin{itemize}
    \item Incorrect Output.
    \item Invalid Instruction.
    \item Error.
  \end{itemize}
  \item Game will be scalable so additional levels/challenges can be added later
  on.
  \item Interface will be suitable for users with certain common disabilities:
  \begin{itemize}
    \item Color blindness.
    \item Deafness.
    \item Epilepsy.
    \item Auditory stimuli sensitivities.
  \end{itemize}
  \item No personally identifiable information about users will be intentionally
  collected or stored.
\end{enumerate}

\subsection{Non-Functional Requirements}
\begin{enumerate}
  \item Demonstrate concepts visually with 2D animations simulating the
  execution of a user’s solution to a challenge.
  \item Allow user to select levels/challenges.
  \item Design a simple pseudo-language with restricted capabilities for the
  user to solve challenges.
  \item Interpret the set of commands in a user’s solution.
  \item Solutions must follow interpreter requirements in order to be simulated
  (similar to compile time errors).
  \item Solution simulation will detect errors and halt immediately if an error
  is encountered (similar to runtime errors).
  \item Store user’s solution attempts for a level.
  \item Check if current solution attempt matches previous solution attempt.
  \item Analyze patterns to detect infinite loop.
  \item Track the steps taken to execute a solutions.
  \item Evaluate the space complexity of a solution by tracking the data
  structures used.
  \item Interface will accommodate users with certain common disabilities:
  \begin{itemize}
    \item Certain interface components (in which color is a significant factor
    for playing the game) will use a color-blind friendly color palette.
    \item Components in which sound is significant to gameplay will have
    corresponding text and/or visual indicators to accommodate deaf users.
    \item Avoid presenting bright flashing colors/lights that may trigger
    epileptic users.
    \item Avoid sudden loud or unpleasant sounds that may disturb users with
    auditory sensitivities.
  \end{itemize}
  \item Game will run on Windows and Mac computers.
  \item Game will perform smoothly on standard hardware.
  \item Game will present efficiency metrics to the player after they
  successfully solve a puzzle.
\end{enumerate}

\newpage
\section{Final Prototype}

\newpage
\section{Design Summary}

\subsection{Overall Project Structure}

\subsection{Game Engine}

\subsection{Puzzle System}

\subsection{User Interface}
\subsubsection{Player Controls}
\subsubsection{Solution Pane}
\subsubsection{Player Messaging}

\subsection{Interpreter}
\subsubsection{Language}
\subsubsection{Parser}
\subsubsection{Executor}

\subsection{Actor}

\newpage
\section{Reseach and Investigations}

\subsection{Ideas}
\subsubsection{Brandy King}
\begin{itemize}
  \item Smaller puzzles can be the parts of a larger cohesive piece
  \begin{itemize}
    \item The efficiency of a solution can dictate how well each piece works
    together
    \item Will reinforce revisiting puzzles that have already been solved to
    find more efficient solutions (leading to a better solution overall)
  \end{itemize}
  \item Variable and Data Structure Declaring
  \begin{itemize}
    \item Separate declaration field from the solution space
    \item Can add or remove variables/structures dynamically
  \end{itemize}
  \item Tutorial levels
  \begin{itemize}
    \item Explaining new instructions or data structures in a non-puzzle level
    \item Allow users to “free play” with their available commands and see how
    things work without the pressure of needing to use them to solve a puzzle
    \item A “to-do” list with checkboxes of key concepts they need for each
    command
    \begin{itemize}
      \item E.G. A Heap tutorial level “to-do” list would include:
      \begin{itemize}
        \item Declare a Heap
        \item Put five inputs in the Heap
        \item Remove five inputs from the Heap
      \end{itemize}
    \end{itemize}
    \item The “to-do” list must be completed before the user can progress to the
    next puzzle, where they will need to utilize the new element in the solution
  \end{itemize}
  \item Points-based scoring of solutions
  \begin{itemize}
    \item Quantify the solution provided with a ranking
    \item Informs users on the efficiency of their solution
  \end{itemize}
  \item Limiting certain commands
  \begin{itemize}
    \item Can’t select to use a data structure space that isn’t declared
    \item Certain commands will not be applicable to data structures
    \begin{itemize}
      \item I.e., data stored in a structure must be removed to be manipulated;
      cannot arbitrarily add or subtract values stored there
    \end{itemize}
    \item Commands with changeable parts will be limited to available locations
  \end{itemize}
  \item Indentation within if statements to emphasize scope
  \begin{itemize}
    \item Will more clearly define to users which commands are reached within
    conditionals; especially important when nested conditionals are introduced
  \end{itemize}
  \item Instruction “Jumbotron”
  \begin{itemize}
    \item An area above the puzzle space that broadcasts which command is being
    executed at that time
  \end{itemize}
\end{itemize}

\subsubsection{John Billingham}
\begin{itemize}
  \item Abstracting conditional jumps with more conventional IF/ELSE statements
  \item Counter that shows how many jumps have been used
  \item Jump iterations used as a finite resource to enforce efficiency
  \item Data Structures as Input/Output
  \begin{itemize}
    \item Arrays, etc
    \item Different data structures unlocked as the puzzle complexity increases
    \item An instruction set associated with each data structure, abstracting
    some of the earlier instructions a bit
  \end{itemize}
  \item Atomic move instructions
  \begin{itemize}
    \item Replacing need to pick up and place down data by combing those into
    one instruction
  \end{itemize}
  \item Add/Subtract specificities
  \item Color-based indexing system
  \item Return instruction
  \item Debugging levels
  \begin{itemize}
    \item Broken solution given initially
    \item Player must fix the broken solution
    \item Can be used in conjunction with tutorials to teach new concepts
  \end{itemize}
\end{itemize}

\subsubsection{Nicolas LaCognata}
\begin{itemize}
  \item Game in the vein of Human Resource Machine
  \begin{itemize}
    \item The player is presented with a limited, assembly-like instruction set
    that they must use to solve logic puzzles.
  \end{itemize}
  \item Data structures as tools
  \begin{itemize}
    \item Data structures are consistently ignored by games in our problem
    space. It would behoove us to take advantage of that gap, and come up with a
    fun and natural way of incorporating data structures into our puzzle format.
  \end{itemize}
  \item Card Game Mechanics
  \begin{itemize}
    \item “Card Playing”
    \begin{itemize}
      \item During our prototyping sessions, I came up with the idea of “Memory
      Cards”. These memory cards would allow the player to declare register
      locations and data structures before their program starts. Making
      mechanics of placing these memory cards similar to a game like Hearthstone
      would be a natural and compelling addition to our puzzle format. This
      “Memory Card” interface would be separate from the normal instruction
      writing interface, which helps reinforce the idea that they are separate
      parts of the puzzle.
    \end{itemize}
    \item “Card packs”
    \begin{itemize}
      \item Card games deliver goodies to players in little packages whose
      contents appear hidden. While discussing adapting card game mechanics, we
      realized that having that little unboxing moment when introducing new
      instructions to the player could be highly compelling.
      \item Other games in our problem space silently drop new instructions on
      the player as they progress. By making the new instructions appear as a
      reward, we can ensure that their addition gets the appropriate attention
      from the player.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsubsection{Sean Simonian}
\begin{itemize}
  \item Static commands and restricted dynamic commands
  \begin{itemize}
    \item Certain commands in the language should be static, such as “Read
    Input”
    \item Certain commands in the language should have components that can be
    selected from drop down menus, such as “Jump if (blank) (blank) (blank)”
    \begin{itemize}
      \item This command would have 3 sections to specify, so the user could
      specify this command to be “Jump if x > 0”
    \end{itemize}
  \end{itemize}
  \item Break more complex challenges into multiple steps that get checked along
  the way.
  \begin{itemize}
    \item User would have instructions to complete one step of the complete
    level challenge at a time, run their solution, and if they pass then they
    move onto the next step, etc., until they work up to the solution.
    \item This would help players grasp more complex concepts that would be
    harder to teach as a single challenge that they have to break down on their
    own.
    \item Example: Merge Sort algorithm
    \begin{itemize}
      \item Step 1: split an array in half
      \item Step 2: split an array in half recursively
      \item Step 3: compare 2 of the sub arrays and swap them if necessary
      \item Step 4: recursively compare and swap sub arrays to build back up to
      the full sorted array
    \end{itemize}
  \end{itemize}
  \item For testing the educational efficacy of the game, we could create a set
  of short questions to be done on paper that require computational thinking.
  Before a test subject plays our game, we have them work through a few of the
  questions. Then after the test subject plays our game, we have them work
  through a few more questions from the set. Compare the results to see if they
  indicate whether our game helps users with computational thinking and problem
  solving.
  \item For testing the educational efficacy of the game, conducting official
  tests through the UCF psych department would be very beneficial if we are able
  to do so.
  \begin{itemize}
    \item Students taking courses such as Intro to Psychology are required to
    spend a certain number of hours as a test subject as part of their course
    grade. They use SONA to view available tests and sign up for a time slot,
    and the experiments that involve playing video games tend to fill up very
    quickly.
    \item Since Intro to Psychology is a general education course, many subjects
    are freshman, and the majority are not studying computer science or similar
    majors. This could provide an abundant set of candidates that match our
    target audience.
    \item We have to figure out who to contact if we want to set this up for
    next semester.
    \item The UCF psychology department may only allow these official tests to
    be set up and run by psych majors and/or psych graduate students doing
    research. If this is the case, we could look for a grad student conducting
    educational research who would be interested in “sponsoring” these official
    tests.
  \end{itemize}
  \item Incorporate basic cyber security and cryptography concepts into additional
  challenges/puzzles.
  \begin{itemize}
    \item This was a goal early on, but the current design for the game
    mechanics would make this difficult to add to the game.
  \end{itemize}
  \item Initial ideas for computer science concepts to teach. As we narrowed
  down the specifications for our game, these ideas were thrown out as they will
  not fit in the game at all
  \begin{itemize}
    \item Artificial intelligence, neural networks, machine learning
    \item Blockchain technology and its applications
  \end{itemize}
\end{itemize}

\subsection{Papers}
During the prototyping phase of our project, we took the time to study research
centered around teaching computational thinking to beginners, with a special
interest in articles focused on game-based delivery of concepts. We wanted to
know how previous attempts at this approach succeeded and to ascertain which
parts were not successful, what caused them to fail, and how we can avoid the
same pitfalls in our own project. That way, we could make an informed decision
on the progression and clarity of instruction within our game.\\

One study was centered on a program designed to observe students’ abilities in
using Scratch to develop solutions for solving computationally based problems
[1]. Scratch is a drag-and-drop block-style programming interface designed for
children to help them learn how to code without requiring them to navigate the
intricacies of typing and compiling code. The program consisted of a discussion
of the topic coupled with a demonstration in Scratch and an emphasis on the
applicable computational thinking skills required, followed by students creating
their own Scratch based solutions [1]. The programs that the students developed
were evaluated for their ability to decompose the problem at hand and the skill
in efficient program development [1]. The study found that basic concepts like
sequence were easy for students to pick up on, but that as program requirements
became more sophisticated it was increasingly difficult for the participants to
compose and debug their programs [1]. Applying these findings to our own
sequence of instruction has informed us on the importance of properly conveying
the progression of topics. It is essential that we not only deliver clear
information about the mechanics of each element of our game, but also that we
properly articulate and demonstrate the more complex topics, such as nested if
statements or nested loops. The sequence of instructions and data structures
being introduced needs to support a logical progression from simple to more
complex topics, and it is necessary to ensure that players are familiar with
concepts before a new one is introduced. For example, we wouldn’t want to
introduce new instructions in succession, but rather require the player to solve
several puzzles with each element to build familiarity and comfort before a new
element is introduced.  Additionally, we recognize that proper conveyance of
debugging practices and insightful feedback on this practice is an integral
aspect of user success.\\

\todo{(if you have any research on computational thinking that you want to include,
but that isn’t focused specifically on using games to teach it, it should go
before the following paragraph. Make sure you update the references as required
- the list of references must be presented in the same order as each citation
first appears in the documentation, and if any citation moves down on the list,
it’s citation needs to be updated within the documentation)}\\

Other research we found concentrated more specifically on the effectiveness of
using games as a medium for teaching computational thinking to users.
Documentation concentrating on this topic was of special interest to us, as it
applies so directly to our goals for this project. There are already many
studies based around the idea of using game-based instruction for teaching, and
it has been firmly established that it is a successful medium for delivering
instructional content. The real issue we are facing is whether or not it can be
used effectively in regard to teaching computational thinking.\\

One such study we found aimed to teach computational thinking concepts using
“unplugged” games to teach the elements, and then following the unplugged
activities the students would apply what they had learned to correlated
“plugged-in” programming exercises [2]. The unplugged version included tangible
real world objects (e.g., a deck of cards) that students would physically
interact with in order to demonstrate understanding of a particular concept, and
the plugged-in version would present the participants with the same object
computationally and ask them to trace through a solution based on the concept
and rules they were already familiar with for that particular object. The
reasoning for this abstract approach is that the underlying computational
concepts can be learned in any medium, and that by removing the technological
applications the emphasis is specifically on the processing of information using
computational thinking instead of having the participants focus too much on the
technology they are using [2]. It was found that for most of the activities, a
majority of the students were able to accurately solve the tasks on the plugged-
in assessments with approximately 90 percent correctness [2]. However, the
activity that aimed to teach students about conditionals and nested conditionals
had very disappointing results, with students only solving 6 percent of the final
assessment for that lesson correctly [2]. There was also a questionnaire element
to this study designed to help the researchers measure the interest the students
had in pursuing an IT-related job, which the students filled out both before the
course and after it ended. Interestingly, the results actually indicated a
slight decline in students interested in choosing a related job after completing
the course, but contrastingly showed an increase in the desire to learn more
about computer science, and also indicated that students enjoyed the course and
felt they learned something valuable [2]. The shortcomings of this study with
respect to teaching conditionals can likely be attributed to not spending enough
time on the topic and the ending assessment being too complex [2]. This has
greatly informed us on how we want to introduce this topic within our own
project. First, we would like to introduce single conditionals in a tutorial
level and then have the user solve a non-trivial puzzle using the concept,
followed with another tutorial level showing them how to operate with nested
conditionals and a subsequent puzzle implementing that technique. Layering this
instruction instead of releasing it to them all at once should help users
understand the basics of conditionals before allowing them to get bogged down in
more complex applications. It should also be noted that the instructors for this
study were trained in teaching for only two hours a week over the course of
three months [2], whereas, cumulatively, the members of our team have years of
experience in teaching these concepts to novices. Still, the results of the
overall effectiveness of gamification of computational thinking concepts as a
solid method for instruction is very promising, and with the right approach we
know that our project can be successful.\\

\todo{(any research papers you need to report on that apply specifically to
game-based delivery of instruction should follow this paragraph; again, please
make sure you update the references accordingly -- both within this section and
in the references section, by order of appearance)}

\subsection{Initial Game Structure}

\subsection{Prototypes}
\subsubsection{Brandy King}
\subsubsection{John Billingham}
\subsubsection{Nicolas LaCognata}
\subsubsection{Sean Simonian}

\newpage
\section{Budget and Financing}
There are no known budget or financing requirements at this time.\\
Current budget: \$0\\
Financing: \$0\\
Sponsorship: \$0\\

\newpage
\section{Milestones}

\subsection{Big Prototype Party}
\subsubsection{Summary}
\subsubsection{Deliverables}

\subsection{Game Pitch}
\subsubsection{Summary}
\subsubsection{Deliverables}

\subsection{Paper Prototype 2.0}
\subsubsection{Summary}
\subsubsection{Deliverables}

\subsection{Hello Game}
\subsubsection{Summary}
\subsubsection{Deliverables}

\subsection{Waterfall Method}
\subsubsection{Summary}
\subsubsection{Deliverables}

\subsection{Open to Interpretation}
\subsubsection{Summary}
\subsubsection{Deliverables}

\subsection{Turing Complete}
\subsubsection{Summary}
\subsubsection{Deliverables}

\subsection{Advanced Puzzles}
\subsubsection{Summary}
\subsubsection{Deliverables}

\subsection{Opening Sequence}
\subsubsection{Summary}
\subsubsection{Deliverables}

\subsection{Playtesting Results}
\subsubsection{Summary}
\subsubsection{Deliverables}

\subsection{Final Product}
\subsubsection{Summary}
\subsubsection{Deliverables}

\newpage
\section{Project Summary and Conclusions}

\newpage
\section{References}

\newpage
\section{Appendices}

\end{document}
